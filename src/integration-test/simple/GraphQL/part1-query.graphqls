
type Query {
    field0: String @onField(arg2: 1)
    field1(arg1: InputQueryArg1 = {id: "0"}, arg2: [InputQueryArg2!]!, arg3: EnumQueryArg3): TypeQueryField1
    field2(arg2: [InputQueryArg2!]! first: Int before: String after: String): UnionQueryField2Connection @connection(for: "UnionQueryField2")
}

input InputQueryArg1 {
    id: ID!
}

input InputQueryArg2 {
    id: ID!
}

enum EnumQueryArg3 {
    V1 V2 V3 V4 V5
}

type TypeQueryField1 {
    idA: Int!
    idB: Int!
    id: ID
}

type TreeNode {
    left: TreeNode
    right: TreeNode
    value: String
}

interface Interface1 {
    node: TreeNode
}

type Type1UnionField2 implements Interface1 {
    fieldA: ID
    node: TreeNode
}

type Type2UnionField2 implements Interface1 {
    name: String
    node: TreeNode
}

union UnionQueryField2 = Type1UnionField2 | Type2UnionField2

interface Interface2 {
    name: String
}

type Type3UnionField2 implements Interface2 {
    fieldC: Int
    name: String
}

extend union UnionQueryField2 = Type3UnionField2
